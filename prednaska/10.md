---
jupytext:
  cell_metadata_filter: -all
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.11.5
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

# Modely dravce a kořisti

```{index} single: Model ; dravce a kořisti
```


Model {cite}`begon` kapitola 10


## Lotkův a Volterrův model 

Lotkův Volterrův model jsme poznali v úvodní kapitole k autonomním systémům.
Tento model předpokládá konstantní per-capita rychlost růstu populace kořisti a
tato rychlost je snižována přítomností dravce rychlostí úměrnou velikosti
populace dravce i kořisti. Velikost populace dravce vymírá rychlostí úměrnou
velikosti této populace a kladný člen vyjadřující růst populace je úměrný
velikostem obou populací, tj. velikosti populace predátora i kořisti. To mimo jiné
ignoruje omezenou nosnou kapacitu prostředí. Přesto, že v realitě je vždy nosná
kapacita prostředí omezena, nemusí tato vlastnost model diskvalifikovat z úvah,
protože samotná přítomnost predátora může způsobit, že populace kořisti je
trvale dostatečně pod nosnou kapacitou a mezidruhová konkurence v populaci
kořisti nemá příliš velký vliv. 

Jsou-li $x$ a $y$ velikosti populací kořisti a dravce, má model tvar
$$
\begin{aligned}\frac{\mathrm dx}{\mathrm dt}&=ax-bxy,\\\frac{\mathrm dy}{\mathrm dt}&=-cy+dxy.\end{aligned}
$$

Řešením tohoto modelu jsou periodické trajektorie.

```{code-cell} ipython
:tags: ["hide-input"]
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from scipy.integrate import solve_ivp

```

```{code-cell} ipython
:tags: ["hide-input"]
def prey(x,y,a=1,b=1):
    return a*x - b*x*y

def predator(x,y,c=1,d=0.5):
    return -c*y+d*x*y

def model(t,X,a=1,b=1,c=1,d=0.5):
    x,y = X
    return [prey(x,y,a,b),predator(x,y,c,d)]

meze = [0,10]
pocatecni_podminka = [2,2]
xmax = 6
ymax = 3

t = np.linspace(*meze, 300)
sol = solve_ivp(
    lambda t,X:model(t,X, a=1.5, b=1, c=3, d=1), 
    [0, 15], # interval pro reseni
    [10, 5], # pocatecni podminka
    t_eval=t
)

plt.plot(t, sol.y.T)
plt.xlabel('čas')
plt.legend(['kořist', 'dravec'], shadow=True)
plt.title('Lotkův-Volterrův model dravce a kořisti')
plt.show()
```


```{code-cell} ipython
:tags: ["hide-input"]
x, y = np.meshgrid(np.linspace(0.01, xmax, 15), 
                   np.linspace(0.01, ymax, 15))

# Komponenty vektoroveho pole
u,v = model(0,[x,y])
M = np.sqrt(u**2+v**2) # velikost vektoru

fig,ax = plt.subplots()
ax.quiver(x,y,u/M,v/M,color='gray',units='xy', angles='xy') # vykresleni s jednotkovou delkou
integralni_krivky = ax.streamplot(x, y, u, v, density=0.5, linewidth=1)

t = np.linspace(*meze,800)
reseni = solve_ivp(model,
                   meze,
                   pocatecni_podminka,
                   t_eval = t
                  )

x, y = np.meshgrid(np.linspace(0.01, xmax, 40), 
                   np.linspace(0.01, ymax, 40))

x_nulcline = plt.contour(x, y, prey(x,y), [0], colors='red')
y_nulcline = plt.contour(x, y, predator(x,y), [0], colors='green')

ax.plot(*reseni.y)
ax.set(
    ylim=(0,None), 
    xlim=(0,None),
xlabel="populace kořisti",
ylabel="populace dravce",
title="Lotkův–Volterrův model dravce a kořisti");
```

## Rosenzweigův a MacArthurův model

Obecněji je možné předpokládat růst populace kořisti závislý na hustotě
populace a nelineární trofickou funkci predátora. Toto vede na model 
$$
\begin{aligned}\frac{\mathrm dx}{\mathrm dt}&=x\phi(x)-f(x,y),\\\frac{\mathrm
dy}{\mathrm dt}&=-cy+df(x,y),\end{aligned}
$$
jehož fázový portrét může vypadat například následovně. 

```{code-cell} ipython
:tags: ["hide-input"]

def predator(x,y,c=0.5,d=1.2):
    return -0.04*y + .1*x*y/(4+x)

def prey(x,y,a=1,b=1,K=3):
    return (1-x/10)*x-.3*x*y/(4+x)

def model(t,X,a=1,b=1,c=0.5,d=1.2,K=3):
    x,y = X
    return [prey(x,y,a,b,K),predator(x,y,c,d)]

xmax = 10
ymax = 20
meze = [0,100]
pocatecni_podminka = [2,12]

x, y = np.meshgrid(np.linspace(0.01, xmax, 15), 
                   np.linspace(0.01, ymax, 15))

# Komponenty vektoroveho pole
u,v = model(0,[x,y])
M = np.sqrt(u**2+v**2) # velikost vektoru

fig,ax = plt.subplots()
ax.quiver(x,y,u/M,v/M,color='gray',units='xy', angles='xy') # vykresleni s jednotkovou delkou
integralni_krivky = ax.streamplot(x, y, u, v, density=0.3)

t = np.linspace(*meze,800)
reseni = solve_ivp(model,
                   meze,
                   pocatecni_podminka,
                   t_eval = t
                  )

x, y = np.meshgrid(np.linspace(0.01, xmax, 40), 
                   np.linspace(0.01, ymax, 40))

x_nulcline = plt.contour(x, y, predator(x,y), [0], colors='red')
y_nulcline = plt.contour(x, y, prey(x,y), [0], colors='green')

ax.plot(*reseni.y)
ax.set(
    ylim=(0,None), 
    xlim=(0,None),
xlabel="populace kořisti",
ylabel="populace dravce",
title="Rosenzweigův a MacArthurův model dravce a kořisti");
```


